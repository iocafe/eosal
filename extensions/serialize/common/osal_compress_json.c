/**

  @file    serialize/common/osal_compress_json.c
  @brief   Compress JSON.
  @author  Pekka Lehtikoski
  @version 1.0
  @date    9.11.2011

  Pack and unpack integers for serialization.

  Copyright 2012 - 2019 Pekka Lehtikoski. This file is part of the eosal and shall only be used,
  modified, and distributed under the terms of the project licensing. By continuing to use, modify,
  or distribute this file you indicate that you have read the license and understand and accept
  it fully.

****************************************************************************************************
*/
#include "eosalx.h"
#if OSAL_JSON_COMPRESSION_SUPPORT

typedef enum {
  OSAL_JSON_START_BLOCK = 1,
  OSAL_JSON_END_BLOCK = 2
  OSAL_JSON_VALUE_EMPTY,
  OSAL_JSON_VALUE_STRING,
  OSAL_JSON_VALUE_INTEGER_ZERO,
  OSAL_JSON_VALUE_INTEGER_ONE,
  OSAL_JSON_VALUE_INTEGER,
  OSAL_JSON_VALUE_FLOAT,
  OSAL_JSON_VALUE_STRING
}
osalTagDict;


typedef struct
{
    os_char *ptr;
    os_memsz sz;
    os_memsz n;
}
osalJsonBuf;


typedef struct
{
    /* Current position in JSON source.
     */
    os_char *pos;

    /* Buffer for string being parsed
     */
    osalJsonBuf str;

    /* Buffer for content being created (no dictionary).
     */
    osalJsonBuf content;

    /* Block recursion depth.
     */
  //  os_int depth;
}
osalJsonCompressor;


/**
****************************************************************************************************

  @brief Convert integer to packed serial format.
  @anchor osal_intser_writer

  The osal_compress_json() function pack integer x to serialization format. Serialization
  format is packed by integer value size. Packed format is type independent, number of 
  generated bytes depends on value, not data type.

  First byte NNNSxxxx:
  - NNN number of follower bytes.
  - S sign
  - xxxx Least significant 4 data bits.

  @param  buf Bufffer where to store serialized integer, minimum OSAL_INTSER_BUF_SZ (10) 
          recommended.
  @param  x Integer to pack.
  @return Number of bytes stored in buf. 

****************************************************************************************************
*/
osalStatus osal_compress_json(
    osalStream *dst_dict,
    os_char *json_source)
{
    osalJsonCompressor state;
    os_char c;
    osalStatus s = OSAL_STATUS_FAILED;

    os_memclear(&state, sizeof(state));
    state.pos = json_source;

    osal_parse_json_alloc_buf(&state.str, 32);
    osal_parse_json_alloc_buf(&state.content, 128);

    /* Skip the first '{'
     */
    do
    {
        c = *(state.pos++);
        if (c == '\0') goto getout;
    }
    while (osal_char_isspace(c));
    if (c != '{') goto getout;

    osal_parse_json_recursive(state);


    s = OSAL_SUCCESS;

getout:
    osal_parse_json_release_buf(&state->str);
    osal_parse_json_release_buf(&state->content);
    return s;
}



static osalStatus osal_parse_json_recursive(
    osalJsonCompressor *state)
{
    os_char c, tmp[OSAL_INTSER_BUF_SZ];
    os_int tmp_n;
    os_long dict_ix, ivalue, z, m, e;
    os_double dvalue;
    os_memsz count;

    if (osal_parse_json_tag(state, &dict_ix) return OSAL_STATUS_FAILED;
    dict_ix <<= 4;

    /* Skip the colon separating first double quote
     */
    do {
        c = *(state.pos++);
        if (c == '\0') return OSAL_STATUS_FAILED;
    }
    while (osal_char_isspace(c));
    if (c != ':') return OSAL_STATUS_FAILED;

    /* Skip spaces until beginning of value
     */
    do {
        c = *(state.pos++);
        if (c == '\0') return OSAL_STATUS_FAILED;
    }
    while (osal_char_isspace(c));

    /* If this is a block
     */
    if (c == '{')
    {
        osal_long_to_buf(&state->content, OSAL_JSON_START_BLOCK + dict_ix);
        if (osal_parse_json_recursive(state)) return OSAL_STATUS_FAILED;
        goto value_handled;
    }

    /* If this is a string
     */
    if (c == '\"')
    {
        if (osal_parse_json_quoted_string(&state->str)) return OSAL_STATUS_FAILED;

        /* If empty value.
         */
        if (state.str.buf_n == 0)
        {
            osal_long_to_buf(&state->content, OSAL_JSON_VALUE_EMPTY + dict_ix);
            goto value_handled;
        }

        ivalue = osal_string_to_int(&state->str, &count);
        if (count == state.str.n)
        {
            if (ivalue == 0)
            {
                z = OSAL_JSON_VALUE_INTEGER_ZERO + dict_ix;
            }
            else if (ivalue == 1)
            {
                z = OSAL_JSON_VALUE_INTEGER_ONE + dict_ix;
            }
            else
            {
                z = OSAL_JSON_VALUE_INTEGER + dict_ix;
            }
            osal_long_to_buf(&state->content, z);
            if ((z & 15) == OSAL_JSON_VALUE_INTEGER)
            {
                osal_long_to_buf(&state->content, ivalue);
            }

            goto value_handled;
        }

        dvalue = osal_string_to_double(&state->str, &count);
        os_double osal_string_to_double(
        if (count == state.str.n)
        {
            if (dvalue == 0.0)
            {
                z = OSAL_JSON_VALUE_INTEGER_ZERO + dict_ix;
            }
            else if (dvalue == 1.0)
            {
                z = OSAL_JSON_VALUE_INTEGER_ONE + dict_ix;
            }
            else
            {
                z = OSAL_JSON_VALUE_FLOAT + dict_ix;
            }
            osal_long_to_buf(&state->content, z);
            if ((z & 15) == OSAL_JSON_VALUE_FLOAT)
            {
                osal_double2ints(dvalue, &m, &e);
                osal_long_to_buf(&state->content, m);
                if (m)
                {
                    osal_long_to_buf(&state->content, e);
                }
            }

            goto value_handled;
        }

        tmp_n = osal_intser_writer(tmp, OSAL_JSON_VALUE_STRING + dict_ix);
        osal_parse_json_append_buf(&state->content, tmp, tmp_sz);
        value_dict_ix = osal_add_string_to_json_dict(state);
        goto value_handled;
    }

    /* If this is integer or float
     */
    if (osal_parse_json_number(&state->str)) return OSAL_STATUS_FAILED;




    tag_ix = parse_json_value(source);


//    state.depth--;
    return OSAL_SUCCESS;
}


static osalStatus osal_parse_json_tag(
    osalJsonCompressor *state,
    os_int *dict_ix)
{
    os_char c;

    /* Skip the first double quote
     */
    do {
        c = *(state.pos++);
        if (c == '\0') return OSAL_STATUS_FAILED;
    }
    while (osal_char_isspace(c));
    if (c != '\"') return OSAL_STATUS_FAILED;

    osal_parse_json_quoted_string(&state.str);

    *dict_ix = osal_add_string_to_json_dict(state);

    return OSAL_SUCCESS;
}



static osalStatus osal_parse_json_quoted_string(
    osalJsonBuf *buf)
{
    buf->n = 0;

    /* Skip the first double quote
     */
    while (OS_TRUE)
    {
        c = *(buf->pos++);

        /* If c is quote character
         */
        if (c == '\\')
        {
            c = *(buf->pos++);
        }

        /* If end of the string
         */
        else if (c == '\"')
        {
            state->str.ptr[buf->n++] = '\0';
            return OSAL_SUCCESS;
        }

        /* If unexpected end of file
         */
        else if (c == '\0')
        {
            return OSAL_STATUS_FAILED;
        }

        /* Store the character. Make sure that we have room
         * in buffer for this character and terminating '\0'.
         */
        if (buf->n + 2 > buf->sz)
        {
            osal_parse_json_alloc_buf(buf, 2 * buf->sz);
        }
        buf->ptr[buf->n++] = c;
    }
}


static void osal_parse_json_alloc_buf(
    osalJsonBuf *buf,
    os_memsz request_sz)
{
    os_char *new_ptr;
    os_memsz new_sz, n;

    new_ptr = os_malloc(bytes, &new_sz)

    n = buf->n;
    if (n)
    {
        os_memcpy(new_ptr, buf->ptr, n);
    }
    osal_parse_json_release_buf(buf);

    buf->ptr = new_ptr;
    buf->sz = new_sz;
    buf->n = n;
}


static void osal_parse_json_release_buf(
    osalJsonBuf *buf)
{
    if (buf->sz)
    {
        osal_free(buf->ptr, buf->sz);
    }
    os_memclear(buf, sizeof(osalJson));
}

static void osal_parse_json_append_buf(
    osalJsonBuf *buf,
    const void *data,
    os_memsz data_sz)
{
    if (buf->n + data_sz > buf->sz)
    {
        osal_parse_json_alloc_buf(buf, 2 * buf->sz);
    }
    os_memcpy(buf->ptr + buf->n, data, data_sz);
    buf->n += data_sz;
}

static void osal_long_to_buf(
    osalJsonBuf *buf,
    os_long z)
{
    os_char tmp[OSAL_INTSER_BUF_SZ];
    os_int tmp_n;

    tmp_n = osal_intser_writer(tmp, z);
    osal_parse_json_append_buf(buf, tmp, tmp_sz);
}



typedef struct
{
    os_char *ptr;
    os_memsz sz;
    os_memsz n;
}
osalJsonBuf;


#endif

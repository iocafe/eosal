/**

  @file    secret/common/osal_secret.c
  @brief   Secret (random number) to secure this network node.
  @author  Pekka Lehtikoski
  @version 1.0
  @date    25.1.2020

  We need one "secret" datum to base on security on. Once we have a secret, everything else
  can be "public" and accessible to anyone, at least in encrypred form.

  The secret is generated by the device and never leaves it as is: The secret is 256 bit
  (32 byte) random number which can be accessed only by the device.
  It is used to create password (by cryptographic SHA-256 hash) and as encryption key to

  A secret is generated as needed by osal_make_random_secret() function and stored in
  persistent storage block OS_PBNR_SECRET. At later boots the secret is loaded from persistent
  storage.

  Application should use only following four secret related functions:
  - osal_get_secret()    Get secret as string. Secret is loaded or generated as needed.
                          String buffer size if 46 characters (OSAL_SECRET_STR_SZ).
  - osal_get_password()   Get password as string. Password is sort of limited "secret". It
                          can be transferred over secure connection from device to server.
  - osal_hash_password()  Make cryptographic hash of password. Hash is public information and
                          can be displayed to user, etc. It can be used to compare if
                          password matches but cannot be used as password to gain access.
  - osal_forget_secret() This function can be called by IO device putton push, etc. It
                          restores the security to default state that IO device can
                          be reconfigured. After calling this function IO device is no
                          loner part of any secure IO network.

  To summarize:
  - The secret is 256 bit random number.
  - Seacter can be accessed by secure communication process only, it is not given out.
  - IO node's password is SHA-256 hash of the secret.
  - IO node's hash password is SHA-256 of the node's password. So SHA-256 hash is run twice.

  Copyright 2020 Pekka Lehtikoski. This file is part of the eosal and shall only be used, 
  modified, and distributed under the terms of the project licensing. By continuing to use, modify,
  or distribute this file you indicate that you have read the license and understand and accept 
  it fully.

****************************************************************************************************
*/
#include "eosalx.h"
#if OSAL_SECRET_SUPPORT

/** Size of string buffer for storing the secret or passowrd.
 */
#define OSAL_SECRET_STR_SZ 46

static os_char osal_group_to_asc(os_uchar x);
static osalStatus ioc_load_secret(void);
static osalStatus ioc_save_secret(os_boolean delete_secret);

/* Get secret. This is used for encrypting private key of TLS server so it can be saved
   as normal data.
 */
void osal_get_secret(
    os_char *buf,
    os_memsz buf_sz)
{
    osal_initialize_secret();
    os_strncpy(buf, osal_global->secret_str, buf_sz);
}

/* Get password. This is used as IO node password.
 */
void osal_get_password(
    os_char *buf,
    os_memsz buf_sz)
{
    osal_initialize_secret();
    os_strncpy(buf, osal_global->auto_password, buf_sz);
}


/**
****************************************************************************************************

  @brief Calculate SHA-256 cryptographic hash (as string) of password
  @anchor osal_hash_password

  The osal_hash_password() function calculates SHA-256 cryptographic hash of password given as
  argument and stores the result as string into buffer.

  @param   buf Buffer where to store the resulting string. Buffer must be at least 46 bytes.
  @param   password Password to encrypt.
  @param   buf_sz Buffer size in bytes.
  @return  None.

****************************************************************************************************
*/
void osal_hash_password(
    os_char *buf,
    const os_char *password,
    os_memsz buf_sz)
{
    os_uchar md[OSAL_HASH_SZ];

    os_memclear(md, sizeof(md));
    osal_sha256((const os_uchar*)password, os_strlen(password), md);
    osal_secret_bin2str(buf, buf_sz, md, OSAL_HASH_SZ, OS_TRUE);
}


/* Forget the secret (and password). Recreates immediately a new secret.
 */
void osal_forget_secret(void)
{
    ioc_save_secret(OS_TRUE);
    osal_global->secret_initialized = OS_FALSE;
    osal_initialize_secret();
}


/**
****************************************************************************************************

  @brief Convert 6 bit integer to ascii char
  @anchor osal_group_to_asc

  The osal_group_to_asc() function...

  @param   x Integer value 0-63 to convert to ASCII character. Highest two bits are ignored.
  @return  Ascii character corresponding to integer value x: '0'-'9', 'a'-'z', 'A'-'Z', '_' or '-'

****************************************************************************************************
*/
static os_char osal_group_to_asc(
    os_uchar x)
{
    const os_uchar n_alpha = 'z' - 'a' + 1; /* 26 characters */
    x &= 0x3F;

    if (x < 10) return '0' + x;
    x -= 10;
    if (x < n_alpha) return 'a' + x;
    x -= n_alpha;
    if (x < n_alpha) return 'A' + x;
    x -= n_alpha;
    return x ? '-' : '_';
}


/**
****************************************************************************************************

  @brief Convert binary data to secret string
  @anchor osal_secret_bin2str

  The osal_secret_bin2str() function converts binary data to password string and stores the
  result as string into buffer. This is used to both convert encrypted passwords to string
  and to convert random numbers to random password.

  @param   str Buffer where to store the string result. The buffer must be at least 45 bytes, or
           46 if prefix_with_excl_mark is OS_TRUE.
  @param   str_sz Size of the string buffer in bytes.
  @param   data Binary souce data.
  @param   data_sz Binary data size in bytes.
  @param   prefix_with_excl_mark OS_TRUE to prefix resulting string with exclamation mark '!".
           The exclamation mark is used to mark encrypted passwords.
  @return  None.

****************************************************************************************************
*/
void osal_secret_bin2str(
    os_char *str,
    os_memsz str_sz,
    const void *data,
    os_memsz data_sz,
    os_boolean prefix_with_excl_mark)
{
    os_uchar *s, md[3*OSAL_HASH_3_GROUPS];
    os_char *p, buf[OSAL_HASH_STR_SZ];
    os_short count;

    /* Setup source data so that it has 33 bytes. 32 data bited and one 0 byte
     */
    os_memclear(md, sizeof(md));
    if (data_sz > sizeof(md))
    {
        osal_debug_error("Too much data for password");
        data_sz = sizeof(md);
    }
    os_memcpy(md, data, data_sz);

    /* Set up target string buffer so that it has enough space (9*4 + 2 = 36 bytes)
     */
    os_memclear(buf, OSAL_HASH_STR_SZ);
    p = buf;
    s = md;

    /* Convert to string format.
     */
    if (prefix_with_excl_mark) *(p++) = '!';
    count = OSAL_HASH_3_GROUPS;
    while (count--)
    {
        *(p++) = osal_group_to_asc(s[0]);
        *(p++) = osal_group_to_asc(s[0] >> 6 | s[1] << 2);
        *(p++) = osal_group_to_asc(s[1] >> 4 | s[2] << 4);
        *(p++) = (count > 0) ? osal_group_to_asc(s[2] >> 2) : '\0';
        s += 3;
    }
    *p = '\0';

#if OSAL_DEBUG
    if (os_strlen(buf) > str_sz)
    {
        osal_debug_error("Too small password string buffer");
    }
#endif
    os_strncpy(str, buf, str_sz);
}


/**
****************************************************************************************************

  @brief Generate a random secret and password (internal)
  @anchor osal_make_random_secret

  The osal_make_random_secret() function generates a random password string. The random
  password includes 256 bits of entropia.

  @return  None.

****************************************************************************************************
*/
void osal_make_random_secret(void)
{
    #define OSAL_RAND_SECRET_N 4 /* 4 * 64 bits = 256 bits */
    os_long binbuf[OSAL_RAND_SECRET_N];
    os_short i;

    for (i = 0; i < OSAL_RAND_SECRET_N; i++)
    {
        binbuf[i] = osal_rand(0, 0);
    }

    os_memcpy(osal_global->secret_bin, binbuf, OSAL_SECRET_BIN_SZ);
}


/**
****************************************************************************************************

  @brief Initialize secret and password (if not initialized already)
  @anchor osal_initialize_secret

  The osal_initialize_secret() function...
  @return  None.

****************************************************************************************************
*/
void osal_initialize_secret(void)
{
    os_uchar md[OSAL_HASH_SZ];
    os_char password_bin[OSAL_SECRET_BIN_SZ];
    osalStatus s;

    /* If already initialized, do nothing. Mark immediately as initialized before loading
       secret to avoid recustion with persistent code.
     */
    if (osal_global->secret_initialized) return;
    osal_global->secret_initialized = OS_TRUE;

    /* Try to load the secret from persistent storage.
     */
    s = ioc_load_secret();

    /* If failed, generate random secret and save it.
     */
    if (s)
    {
        osal_make_random_secret();

#if OSAL_DEBUG
        if (ioc_save_secret(OS_FALSE))
        {
            osal_debug_error("osal_secret.c: saving secret failed");
        }
#else
        ioc_save_secret();
#endif
    }

    /* Generate secret using cryptographic hash of the binary number.
     */
    os_memclear(md, sizeof(md));
    osal_sha256((const os_uchar*)osal_global->secret_bin, OSAL_SECRET_BIN_SZ, md);
    osal_secret_bin2str(osal_global->secret_str, OSAL_SECRET_STR_SZ, md, OSAL_HASH_SZ, OS_FALSE);

    /* Modify the binary a bit and generate password.
     */
    os_memclear(md, sizeof(md));
    os_memcpy(password_bin, osal_global->secret_bin, OSAL_SECRET_BIN_SZ);
    password_bin[1] ^= 5;
    osal_sha256((const os_uchar*)password_bin, OSAL_SECRET_BIN_SZ, md);
    osal_secret_bin2str(osal_global->auto_password, OSAL_SECRET_STR_SZ, md, OSAL_HASH_SZ, OS_FALSE);
}


/**
****************************************************************************************************

  @brief Load secret from persistent storage.

  The ioc_load_secret function...
  @return  If successfull, the function return OSAL_SUCCESS. Other values indicate an error.

****************************************************************************************************
*/
static osalStatus ioc_load_secret(void)
{
    return ioc_load_persistent(OS_PBNR_SECRET,  osal_global->secret_bin, OSAL_SECRET_BIN_SZ);
}


/**
****************************************************************************************************

  @brief Save secret to persistent storage.

  The ioc_save_secret function writes 256 bit (32 bytes) seacret to persistent block OS_PBNR_SECRET.

  @param   delete_secret OS_TRUE to write a seacret with empty content.
  @return  If successfull, the function return OSAL_SUCCESS. Other values indicate an error.

****************************************************************************************************
*/
static osalStatus ioc_save_secret(os_boolean delete_secret)
{
    return ioc_save_persistent(OS_PBNR_SECRET, osal_global->secret_bin,
        OSAL_SECRET_BIN_SZ, delete_secret);
}

#endif

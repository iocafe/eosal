/**

  @file    tls/mbedtls/osal_mbedtls_aes_crypt.c
  @brief   Simple AES encryption/decryption function using Mbed TLS.
  @author  Pekka Lehtikoski
  @version 1.0
  @date    26.4.2021

  Copyright 2020 Pekka Lehtikoski. This file is part of the eosal and shall only be used,
  modified, and distributed under the terms of the project licensing. By continuing to use, modify,
  or distribute this file you indicate that you have read the license and understand and accept
  it fully.

****************************************************************************************************
*/
#include "eosalx.h"
#if OSAL_TLS_SUPPORT==OSAL_TLS_MBED_WRAPPER
#include "mbedtls/aes.h"

/**
****************************************************************************************************

  @brief Encrypt or decrypt data, AES 256.

  Padding to block size (16 bytes) makes this a bit complex. AES encrypted data size needs to be
  multiple of block size (16) for both encrypting and decrypting.

  Encrypt:

    ClearTextDataStruct data;
    os_uchar encrypted[(sizeof(ClearTextDataStruct) + 0xF) & ~0xF];

    // Calculate checksum.
    data.checksum = 0;
    data.checksum = os_checksum((const os_char*)&data, sizeof(ClearTextDataStruct), OS_NULL);

    // Encrypt the data.
    osal_aes_crypt((os_uchar*)&data, sizeof(ClearTextDataStruct), encrypted, sizeof(encrypted),
        crypt_key, OSAL_AES_ENCRYPT);

    // Write sizeof(encrypted) bytes of encrypted data to file, etc.

  Decrypt:

    ClearTextDataStruct data;
    os_uchar encrypted[(sizeof(ClearTextDataStruct) + 0xF) & ~0xF];

    // Read sizeof(encrypted) bytes of encrypted data from file, etc.

    // Decrypt the data.
    osal_aes_crypt(encrypted, sizeof(encrypted), (os_uchar*)&data, sizeof(ClearTextDataStruct),
        crypt_key, OSAL_AES_DECRYPT);

    saved_checksum = data->checksum;
    data->checksum = 0;
    calculated_checksum = os_checksum((const os_char*)data, sizeof(eLoginData), OS_NULL);
    if (calculated_checksum == saved_checksum) {
        ALL GOOD...
    }

  Crypt key can be generated by osal_initialize_aes_crypt_key() function. It is basically
  just 32 bytes of binary data. Checksum is used to veryfu that decrypted structure makes sense.

  The ClearTextDataStruct is plain flat data structure to encrypt, including checksum. For
  example:

    typedef struct {
        os_char my_secret_string[64];
        os_ushort checksum;
    }
    ClearTextDataStruct;

  @param   data Data to encrypt or decrypt.
  @param   data_sz Data size in bytes. For encrypting, any data size will do, doesn't have to be
           multple of 16. For decrypting this must also be multiple of the block size (16).
  @param   buf Pointer to buffer where to place encrypted/decrypted data, always data_sz bytes
           are stored into buffer. buf can be same pointer as data, and data is overwritten with
           the result.
  @param   buf_sz For encrypting this must be at least the same as data_sz and multiple of
           the block size (16 bytes). For decrypting this can be smaller than data size,
           if there is some zero padding.
  @param   key 256 bit encryption key, 32 bytes.
  @param   operation Either OSAL_AES_ENCRYPT or OSAL_AES_DECRYPT.

****************************************************************************************************
*/
void osal_aes_crypt(
    const os_uchar *data,
    os_memsz data_sz,
    os_uchar *buf,
    os_memsz buf_sz,
    const os_uchar key[OSAL_AES_KEY_SZ],
    osalAesOperation operation)
{
    mbedtls_aes_context aes;
    unsigned char iv[16];
    os_uchar *tmp_data = OS_NULL;
    os_memsz tmp_data_sz = 0;
    os_uchar *tmp_buf = OS_NULL;
    os_memsz tmp_buf_sz = 0;
    os_uchar *target_buf;

    os_memclear(iv, sizeof(iv));

    if (data_sz & 0xF) {
        tmp_data_sz = (data_sz + 0xF) & ~0xF;
        tmp_data = (os_uchar*)os_malloc(tmp_data_sz, OS_NULL);
        os_memcpy(tmp_data, data, data_sz);
        os_memclear(tmp_data + data_sz, tmp_data_sz - data_sz);
        data = tmp_data;
        data_sz = tmp_data_sz;
    }

    if (buf_sz & 0xF || buf_sz < data_sz) {
        tmp_buf_sz = (buf_sz + 0xF) & ~0xF;
        if (tmp_buf_sz < data_sz) {
            tmp_buf_sz = data_sz;
        }
        tmp_buf = (os_uchar*)os_malloc(tmp_buf_sz, OS_NULL);
        os_memclear(tmp_buf, tmp_buf_sz);
        target_buf = tmp_buf;
    }
    else {
        target_buf = buf;
    }

    mbedtls_aes_init(&aes);
    if (operation == OSAL_AES_ENCRYPT)
    {
        mbedtls_aes_setkey_enc(&aes, key, OSAL_AES_BITS);
        mbedtls_aes_crypt_cbc(&aes, MBEDTLS_AES_ENCRYPT,
            data_sz, iv, data, target_buf);
    }
    else {
        mbedtls_aes_setkey_dec(&aes, key, OSAL_AES_BITS);
        mbedtls_aes_crypt_cbc(&aes, MBEDTLS_AES_DECRYPT,
            data_sz, iv, data, target_buf);
    }
    mbedtls_aes_free(&aes);

    if (tmp_buf) {
        os_memcpy(buf, tmp_buf, buf_sz);
        os_free(tmp_buf, tmp_buf_sz);
    }

    if (tmp_data) {
        os_free(tmp_data, tmp_data_sz);
    }
}

#endif

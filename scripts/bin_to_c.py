# bin_to_c.py 26.4.2021/pekka
# Converts a binary file to C character array.
import json
import os
import sys

def start_c_files():
    global ccontent, hcontent, hfilepath
    ccontent = '/* This file is generated by bin_to_c.py script, do not modify. */\n'
    hcontent = '/* This file is generated by bin_to_c.py script, do not modify. */\n'
    path, fname = os.path.split(hfilepath)
    fname, ext = os.path.splitext(fname)
    macroname = 'IOC_' + fname.upper() + '_INCLUDED'
    hcontent += '#ifndef ' + macroname + '\n'
    hcontent += '#define ' + macroname + '\n'
    hcontent += 'OSAL_C_HEADER_BEGINS\n\n'

def finish_c_files():
    global ccontent, hcontent
    hcontent += '\nOSAL_C_HEADER_ENDS\n'
    hcontent += '#endif\n'
 
def process_source_file(path, variablename):
    global ccontent, hcontent

    with open(path, mode='rb') as file: # b is important -> binary
        file_content = file.read()

        l = len(file_content)

        ccontent += 'OS_PROGMEM os_uchar ' + variablename + '[' + str(l) + '] = {\n'
        hcontent += 'extern OS_PROGMEM_H os_uchar ' + variablename + '[' + str(l) + '];\n'

        columns = 0
        for x in range(0, l):
            if columns >= 25:
                ccontent += "\n"
                columns = 0
            ccontent += str(file_content[x]);
            if x < l - 1:
                ccontent += ","

            columns = columns + 1

        ccontent += '};\n'


# Write a file only if content has changed
def write_file_only_if_changed(filepath, content):
    if (os.path.isfile(filepath)):
        hfile = open(filepath, "r")
        old_content = hfile.read()
        hfile.close()
        if (content == old_content):
            return

    print("Writing bin_to_c file " + filepath)

    hfile = open(filepath, "w")
    hfile.write(content)
    hfile.close()

def mymain():
    global cfilepath, hfilepath
    global ccontent, hcontent

    # Get command line arguments
    n = len(sys.argv)
    sourcefiles = []
    outpath = None
    variablename = "noame"
    expectpath = True
    for i in range(1, n):
        if sys.argv[i][0] == "-":
            if sys.argv[i][1] == "o":
                outpath = sys.argv[i+1]
                expectpath = False

            if sys.argv[i][1] == "v":
                variablename = sys.argv[i+1]
                expectpath = False

        else:
            if expectpath:
                sourcefiles.append(sys.argv[i])
            expectpath = True

    if len(sourcefiles) < 1:
        print("No source files")
        exit()

    if outpath is None:
        outpath = sourcefiles[0]

    filename, file_extension = os.path.splitext(outpath)
    cfilepath = filename + '.c'
    hfilepath = filename + '.h'

    start_c_files()

    for path in sourcefiles:
        process_source_file(path, variablename)

    finish_c_files()

    write_file_only_if_changed(cfilepath, ccontent)
    write_file_only_if_changed(hfilepath, hcontent)

mymain()
